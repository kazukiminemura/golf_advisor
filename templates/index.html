<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>チャット & 動画</title>
  <style>
    body { display: flex; height: 100vh; margin: 0; }
    .video-container, .chat-container { flex: 1; padding: 10px; box-sizing: border-box; }
    .chat-container { display: flex; flex-direction: column; }
    #chat-messages { flex: 1; border: 1px solid #ccc; overflow-y: auto; margin-bottom: 10px; padding: 5px; }
    .chat-input { display: flex; }
    .chat-input input { flex: 1; padding: 5px; }
    .chat-input button { margin-left: 5px; }
    .chat-status { 
      background: #f0f0f0; 
      padding: 10px; 
      margin-bottom: 10px; 
      border-radius: 5px; 
      text-align: center;
      font-weight: bold;
    }
    .chat-status.preparing { background: #fff3cd; color: #856404; }
    .chat-status.ready { background: #d4edda; color: #155724; }
    .chat-status.error { background: #f8d7da; color: #721c24; }
    .video-wrapper { display: flex; }
    .video-item { position: relative; flex: 1; }
    .video-item video { width: 100%; display: block; }
    .video-item canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
    .file-select { margin-bottom: 10px; }
    .file-select select { width: 45%; margin-right: 5px; }
    .file-select input[type="file"] { width: 45%; margin-right: 5px; }
    #usage div { margin-bottom: 4px; }
    #usage progress { width: 60%; }
  </style>
</head>
<body>
  <!-- 動画 -->
  <div class="video-container">
    <div class="file-select">
      <label for="ref-upload">参照</label>
      <input id="ref-upload" type="file" accept="video/mp4" />
      <select id="ref-file"></select>
      <label for="cur-upload">対象</label>
      <input id="cur-upload" type="file" accept="video/mp4" />
      <select id="cur-file"></select>
      <label for="device-select">デバイス</label>
      <select id="device-select">
        <option value="CPU">CPU</option>
        <option value="GPU">GPU</option>
        <option value="NPU">NPU</option>
      </select>
      <button id="process-btn">更新＆解析</button>
    </div>
    <div id="status"></div>
    <div id="usage">
      <div>CPU: <progress id="cpu-bar" max="100" value="0"></progress> <span id="cpu-text">0%</span></div>
      <div>GPU: <progress id="gpu-bar" max="100" value="0"></progress> <span id="gpu-text">0%</span></div>
      <div>NPU: <progress id="npu-bar" max="100" value="0"></progress> <span id="npu-text">0%</span></div>
    </div>
    {% if has_results %}
    <p>差分スコア: {{ "%.4f"|format(score) }}</p>
    <div class="video-wrapper">
      <div class="video-item">
        <video id="ref-video" controls loop>
          <source src="{{ url_for('serve_video', filename=ref_video_name) }}" type="video/mp4">
          お使いのブラウザは動画再生に対応していません。
        </video>
        <canvas id="ref-canvas"></canvas>
      </div>
      <div class="video-item">
        <video id="cur-video" controls loop>
          <source src="{{ url_for('serve_video', filename=cur_video_name) }}" type="video/mp4">
          お使いのブラウザは動画再生に対応していません。
        </video>
        <canvas id="cur-canvas"></canvas>
      </div>
    </div>
    {% endif %}
  </div>

  {% if chatbot_enabled %}
  <!-- チャット -->
  <div class="chat-container">
    <div id="chat-status" class="chat-status preparing">
      チャットボットは準備中です。まず動画を分析してください。
    </div>
    <div id="chat-messages"></div>
    <div class="chat-input">
      <input id="chat-input" type="text" placeholder="メッセージを入力..." disabled />
      <button id="send-btn" disabled>送信</button>
    </div>
  </div>
  {% endif %}

  <script>
    const HAS_RESULTS = {{ 'true' if has_results else 'false' }};
    const CHATBOT_ENABLED = {{ 'true' if chatbot_enabled else 'false' }};
    const CURRENT_DEVICE = '{{ device }}';

    let chatbotReady = false;

    // チャットDOMの存在で機能を有効化（環境変数に依存しない安全策）
    if (document.getElementById('chat-input')) {
      async function update_chatbot_status() {
        try {
          const res = await fetch('/chatbot_status');
          const status = await res.json();
          const statusDiv = document.getElementById('chat-status');
          const chatInput = document.getElementById('chat-input');
          const sendBtn = document.getElementById('send-btn');
          
          if (status.initialized) {
            statusDiv.textContent = "チャットボットの準備ができました。";
            statusDiv.className = "chat-status ready";
            chatInput.disabled = false;
            sendBtn.disabled = false;
            chatInput.placeholder = "メッセージを入力...";
            chatbotReady = true;
          } else if (status.analysis_complete) {
            statusDiv.textContent = "動画分析が完了しました。チャットボットの準備ができました！";
            statusDiv.className = "chat-status ready";
            chatInput.disabled = false;
            sendBtn.disabled = false;
            chatInput.placeholder = "メッセージを入力...";
            chatbotReady = true;
          } else {
            statusDiv.textContent = "チャットボットは準備中です。まず動画を分析してください。";
            statusDiv.className = "chat-status preparing";
            chatInput.disabled = true;
            sendBtn.disabled = true;
            chatInput.placeholder = "分析を完了してください...";
            chatbotReady = false;
          }
        } catch (e) {
          const statusDiv = document.getElementById('chat-status');
          statusDiv.textContent = "チャットボット状態の取得に失敗しました。";
          statusDiv.className = "chat-status error";
          chatbotReady = false;
        }
      }

      async function load_messages() {
        if (!chatbotReady) return;
        
        try {
          const res = await fetch('/messages');
          const msgs = await res.json();
          const box = document.getElementById('chat-messages');
          box.innerHTML = '';
          msgs.forEach(m => {
            const p = document.createElement('p');
            const prefix = m.role === 'user' ? 'あなた: ' : 'コーチ: ';
            p.textContent = prefix + m.content;
            box.appendChild(p);
          });
          box.scrollTop = box.scrollHeight;
        } catch (e) {
          console.error('Failed to load messages:', e);
        }
      }

      async function init_chat() {
        await update_chatbot_status();
        // 解析済みであれば、サーバ状態取得に失敗しても入力を先に有効化
        if (HAS_RESULTS) {
          const statusDiv = document.getElementById('chat-status');
          const chatInput = document.getElementById('chat-input');
          const sendBtn = document.getElementById('send-btn');
          statusDiv.textContent = "動画分析が完了しました。チャットボットの準備ができました！";
          statusDiv.className = "chat-status ready";
          chatInput.disabled = false;
          sendBtn.disabled = false;
          chatInput.placeholder = "メッセージを入力...";
          chatbotReady = true;
        }
        // 初期化はバックグラウンドで試行
        try {
          await fetch('/init_chatbot', { method: 'POST' });
        } catch (e) {
          console.warn('Chatbot init may have failed:', e);
        }
        await update_chatbot_status();
        await load_messages();
      }

      document.getElementById('send-btn').onclick = async () => {
        if (!chatbotReady) return;
        
        const input = document.getElementById('chat-input');
        const text = input.value.trim();
        if (!text) return;
        const box = document.getElementById('chat-messages');

        // 送信したメッセージを即座に表示
        const userP = document.createElement('p');
        userP.textContent = 'あなた: ' + text;
        box.appendChild(userP);
        box.scrollTop = box.scrollHeight;

        input.value = '';

        // 送信中の表示
        const loadingP = document.createElement('p');
        loadingP.textContent = 'コーチ: 考え中...';
        loadingP.style.opacity = '0.6';
        box.appendChild(loadingP);
        box.scrollTop = box.scrollHeight;

        try {
          const res = await fetch('/messages', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ message: text })
          });
          const data = await res.json();

          // ローディング表示を削除
          box.removeChild(loadingP);

          const coachP = document.createElement('p');
          coachP.textContent = 'コーチ: ' + data.reply;
          box.appendChild(coachP);
          box.scrollTop = box.scrollHeight;
        } catch (e) {
          // ローディング表示を削除
          box.removeChild(loadingP);
          
          const errP = document.createElement('p');
          errP.textContent = 'コーチ: 返答の取得に失敗しました。';
          errP.style.color = 'red';
          box.appendChild(errP);
          box.scrollTop = box.scrollHeight;
        }
      };

      // Enterキーでメッセージ送信
      document.getElementById('chat-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey && chatbotReady) {
          e.preventDefault();
          document.getElementById('send-btn').click();
        }
      });
    }

    document.getElementById('process-btn').onclick = async () => {
      const refSel = document.getElementById('ref-file').value;
      const curSel = document.getElementById('cur-file').value;
      const device = document.getElementById('device-select').value;
      const refUp = document.getElementById('ref-upload').files[0];
      const curUp = document.getElementById('cur-upload').files[0];

      let refFile = refSel;
      let curFile = curSel;

      if (refUp || curUp) {
        const form = new FormData();
        if (refUp) form.append('reference', refUp);
        if (curUp) form.append('current', curUp);
        const upRes = await fetch('/upload_videos', { method: 'POST', body: form });
        const uploaded = await upRes.json();
        if (uploaded.reference_file) refFile = uploaded.reference_file;
        if (uploaded.current_file) curFile = uploaded.current_file;
      }

      await fetch('/set_videos', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ reference_file: refFile, current_file: curFile, device })
      });

      const status = document.getElementById('status');
      status.textContent = '解析中';
      
      // チャットボット状態を分析中に更新
      if (CHATBOT_ENABLED) {
        const statusDiv = document.getElementById('chat-status');
        statusDiv.textContent = "動画分析中です。しばらくお待ちください...";
        statusDiv.className = "chat-status preparing";
        document.getElementById('chat-input').disabled = true;
        document.getElementById('send-btn').disabled = true;
        chatbotReady = false;
      }
      
      let dots = 0;
      const timer = setInterval(() => {
        dots = (dots + 1) % 4;
        status.textContent = '解析中' + '.'.repeat(dots);
      }, 500);
      
      let analyzeData = null;
      try {
        const analyzeRes = await fetch('/analyze', { method: 'POST' });
        // Robust JSON handling
        const ct = (analyzeRes.headers.get('Content-Type') || '').toLowerCase();
        if (!ct.includes('application/json')) {
          throw new Error('Invalid response type');
        }
        analyzeData = await analyzeRes.json();
      } catch (e) {
        clearInterval(timer);
        status.textContent = '解析に失敗しました。';
        if (CHATBOT_ENABLED) {
          const statusDiv = document.getElementById('chat-status');
          statusDiv.textContent = "分析中にエラーが発生しました。";
          statusDiv.className = "chat-status error";
        }
        return;
      }

      clearInterval(timer);

      if (analyzeData && analyzeData.error) {
        status.textContent = '解析に失敗しました: ' + analyzeData.error;
        if (CHATBOT_ENABLED) {
          const statusDiv = document.getElementById('chat-status');
          statusDiv.textContent = "分析に失敗しました。再度お試しください。";
          statusDiv.className = "chat-status error";
        }
        return;
      }

      // 成功時
      status.textContent = '解析完了';

      // チャットボット状態の更新は失敗しても無視（解析結果は成功として扱う）
      if (CHATBOT_ENABLED) {
        try {
          await update_chatbot_status();
          await load_messages();
        } catch (_) {
          // ignore chat update errors
        }
      }

      // 結果表示のため軽く待ってから再読み込み
      setTimeout(() => location.reload(), 1000);
    };

    async function load_video_list() {
      const res = await fetch('/list_videos');
      const files = await res.json();
      const refSel = document.getElementById('ref-file');
      const curSel = document.getElementById('cur-file');
      refSel.innerHTML = '';
      curSel.innerHTML = '';
      files.forEach(f => {
        const o1 = document.createElement('option');
        o1.value = f;
        o1.textContent = f;
        refSel.appendChild(o1);
        const o2 = document.createElement('option');
        o2.value = f;
        o2.textContent = f;
        curSel.appendChild(o2);
      });
      refSel.value = '{{ ref_video_name }}';
      curSel.value = '{{ cur_video_name }}';
    }

    const POSE_PAIRS = [
      [1,2],[2,3],[3,4],
      [1,5],[5,6],[6,7],
      [1,8],[8,9],[9,10],
      [8,12],[12,13],[13,14],
      [0,1],[0,15],[15,17],[0,16],[16,18]
    ];

    async function load_keypoints(url) {
      const res = await fetch(url);
      return await res.json();
    }

    function setup_overlay(videoId, canvasId, data) {
      const video = document.getElementById(videoId);
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');

      function draw_frame() {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const frame = Math.floor(video.currentTime * data.fps);
        const kps = data.keypoints[frame];
        if (kps) {
          kps.forEach(([x,y,conf]) => {
            if (conf > 0.3) {
              const px = x * canvas.width;
              const py = y * canvas.height;
              ctx.beginPath();
              ctx.arc(px, py, 3, 0, Math.PI * 2);
              ctx.fillStyle = 'lime';
              ctx.fill();
            }
          });
          POSE_PAIRS.forEach(([a,b]) => {
            const pa = kps[a], pb = kps[b];
            if (pa && pb && pa[2] > 0.3 && pb[2] > 0.3) {
              ctx.beginPath();
              ctx.moveTo(pa[0] * canvas.width, pa[1] * canvas.height);
              ctx.lineTo(pb[0] * canvas.width, pb[1] * canvas.height);
              ctx.strokeStyle = 'blue';
              ctx.lineWidth = 2;
              ctx.stroke();
            }
          });
        }
        requestAnimationFrame(draw_frame);
      }
      requestAnimationFrame(draw_frame);
    }

    if (HAS_RESULTS) {
      Promise.all([
        load_keypoints("{{ url_for('static', filename='reference_keypoints.json') }}"),
        load_keypoints("{{ url_for('static', filename='current_keypoints.json') }}")
      ]).then(([refData, curData]) => {
        setup_overlay('ref-video', 'ref-canvas', refData);
        setup_overlay('cur-video', 'cur-canvas', curData);
      });

      const refVideo = document.getElementById('ref-video');
      const curVideo = document.getElementById('cur-video');

      function sync_play(from, to) {
        if (to.paused) {
          to.currentTime = from.currentTime;
          to.play();
        }
      }

      refVideo.addEventListener('play', () => sync_play(refVideo, curVideo));
      curVideo.addEventListener('play', () => sync_play(curVideo, refVideo));
      refVideo.addEventListener('pause', () => { if (!curVideo.paused) curVideo.pause(); });
      curVideo.addEventListener('pause', () => { if (!refVideo.paused) refVideo.pause(); });
    }

    // 初期表示
    load_video_list();
    document.getElementById('device-select').value = CURRENT_DEVICE;
    
    if (document.getElementById('chat-input')) {
      init_chat();
      // 定期的にチャットボット状態をチェック
      setInterval(update_chatbot_status, 5000);
    }
    
    async function update_usage() {
      try {
        const res = await fetch('/system_usage');
        const data = await res.json();
        // Ensure bars display correct metrics
        document.getElementById('cpu-bar').value = data.cpu;
        document.getElementById('gpu-bar').value = data.gpu;
        document.getElementById('npu-bar').value = data.npu;
        document.getElementById('cpu-text').textContent = `${data.cpu.toFixed(1)}%`;
        document.getElementById('gpu-text').textContent = `${data.gpu.toFixed(1)}%`;
        document.getElementById('npu-text').textContent = `${data.npu.toFixed(1)}%`;
      } catch (e) {
        // ignore errors
      }
    }
    setInterval(update_usage, 1000);
    update_usage();
  </script>
</body>
</html>
