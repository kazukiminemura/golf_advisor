<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>チャット & 動画</title>
  <style>
    body { display: flex; height: 100vh; margin: 0; }
    .video-container, .chat-container { flex: 1; padding: 10px; box-sizing: border-box; }
    .chat-container { display: flex; flex-direction: column; }
    #chat-messages { flex: 1; border: 1px solid #ccc; overflow-y: auto; margin-bottom: 10px; padding: 5px; }
    .chat-input { display: flex; }
    .chat-input input { flex: 1; padding: 5px; }
    .chat-input button { margin-left: 5px; }
    .video-wrapper { display: flex; }
    .video-item { position: relative; flex: 1; }
    .video-item video { width: 100%; display: block; }
    .video-item canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
    .file-select { margin-bottom: 10px; }
    .file-select select { width: 45%; margin-right: 5px; }
    .file-select input[type="file"] { width: 45%; margin-right: 5px; }
    #usage div { margin-bottom: 4px; }
    #usage progress { width: 60%; }
  </style>
</head>
<body>
  <!-- 動画 -->
  <div class="video-container">
    <div class="file-select">
      <label for="ref-upload">参照</label>
      <input id="ref-upload" type="file" accept="video/mp4" />
      <select id="ref-file"></select>
      <label for="cur-upload">対象</label>
      <input id="cur-upload" type="file" accept="video/mp4" />
      <select id="cur-file"></select>
      <button id="process-btn">更新＆解析</button>
    </div>
    <div id="status"></div>
    <div id="usage">
      <div>CPU: <progress id="cpu-bar" max="100" value="0"></progress> <span id="cpu-text">0%</span></div>
      <div>GPU: <progress id="gpu-bar" max="100" value="0"></progress> <span id="gpu-text">0%</span></div>
      <div>NPU: <progress id="npu-bar" max="100" value="0"></progress> <span id="npu-text">0%</span></div>
    </div>
    {% if has_results %}
    <p>差分スコア: {{ "%.4f"|format(score) }}</p>
    <div class="video-wrapper">
      <div class="video-item">
        <video id="ref-video" controls loop>
          <source src="{{ url_for('serve_video', filename=ref_video_name) }}" type="video/mp4">
          お使いのブラウザは動画再生に対応していません。
        </video>
        <canvas id="ref-canvas"></canvas>
      </div>
      <div class="video-item">
        <video id="cur-video" controls loop>
          <source src="{{ url_for('serve_video', filename=cur_video_name) }}" type="video/mp4">
          お使いのブラウザは動画再生に対応していません。
        </video>
        <canvas id="cur-canvas"></canvas>
      </div>
    </div>
    {% endif %}
  </div>

  {% if chatbot_enabled %}
  <!-- チャット -->
  <div class="chat-container">
    <div id="chat-messages"></div>
    <div class="chat-input">
      <input id="chat-input" type="text" placeholder="メッセージを入力..." />
      <button id="send-btn">送信</button>
    </div>
  </div>
  {% endif %}

  <script>
    const HAS_RESULTS = {{ 'true' if has_results else 'false' }};
    const CHATBOT_ENABLED = {{ 'true' if chatbot_enabled else 'false' }};

    if (CHATBOT_ENABLED) {
      async function load_messages() {
        const res = await fetch('/messages');
        const msgs = await res.json();
        const box = document.getElementById('chat-messages');
        box.innerHTML = '';
        msgs.forEach(m => {
          const p = document.createElement('p');
          const prefix = m.role === 'user' ? 'あなた: ' : 'コーチ: ';
          p.textContent = prefix + m.content;
          box.appendChild(p);
        });
        box.scrollTop = box.scrollHeight;
      }

      async function init_chat() {
        try {
          await fetch('/init_chatbot', { method: 'POST' });
        } catch (e) {
          // ignore
        }
        await load_messages();
      }

      document.getElementById('send-btn').onclick = async () => {
        const input = document.getElementById('chat-input');
        const text = input.value.trim();
        if (!text) return;
        const box = document.getElementById('chat-messages');

        // 送信したメッセージを即座に表示
        const userP = document.createElement('p');
        userP.textContent = 'あなた: ' + text;
        box.appendChild(userP);
        box.scrollTop = box.scrollHeight;

        input.value = '';

        try {
          const res = await fetch('/messages', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ message: text })
          });
          const data = await res.json();

          const coachP = document.createElement('p');
          coachP.textContent = 'コーチ: ' + data.reply;
          box.appendChild(coachP);
          box.scrollTop = box.scrollHeight;
        } catch (e) {
          const errP = document.createElement('p');
          errP.textContent = 'コーチ: 返答の取得に失敗しました。';
          box.appendChild(errP);
          box.scrollTop = box.scrollHeight;
        }
      };
    }

    document.getElementById('process-btn').onclick = async () => {
      const refSel = document.getElementById('ref-file').value;
      const curSel = document.getElementById('cur-file').value;
      const refUp = document.getElementById('ref-upload').files[0];
      const curUp = document.getElementById('cur-upload').files[0];

      let refFile = refSel;
      let curFile = curSel;

      if (refUp || curUp) {
        const form = new FormData();
        if (refUp) form.append('reference', refUp);
        if (curUp) form.append('current', curUp);
        const upRes = await fetch('/upload_videos', { method: 'POST', body: form });
        const uploaded = await upRes.json();
        if (uploaded.reference_file) refFile = uploaded.reference_file;
        if (uploaded.current_file) curFile = uploaded.current_file;
      }

      await fetch('/set_videos', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ reference_file: refFile, current_file: curFile })
      });

      const status = document.getElementById('status');
      status.textContent = '解析中';
      let dots = 0;
      const timer = setInterval(() => {
        dots = (dots + 1) % 4;
        status.textContent = '解析中' + '.'.repeat(dots);
      }, 500);
      try {
        await fetch('/analyze', { method: 'POST' });
        clearInterval(timer);
        status.textContent = '解析完了';
        location.reload();
      } catch (e) {
        clearInterval(timer);
        status.textContent = '解析に失敗しました。';
      }
    };

    async function load_video_list() {
      const res = await fetch('/list_videos');
      const files = await res.json();
      const refSel = document.getElementById('ref-file');
      const curSel = document.getElementById('cur-file');
      refSel.innerHTML = '';
      curSel.innerHTML = '';
      files.forEach(f => {
        const o1 = document.createElement('option');
        o1.value = f;
        o1.textContent = f;
        refSel.appendChild(o1);
        const o2 = document.createElement('option');
        o2.value = f;
        o2.textContent = f;
        curSel.appendChild(o2);
      });
      refSel.value = '{{ ref_video_name }}';
      curSel.value = '{{ cur_video_name }}';
    }

    const POSE_PAIRS = [
      [1,2],[2,3],[3,4],
      [1,5],[5,6],[6,7],
      [1,8],[8,9],[9,10],
      [8,12],[12,13],[13,14],
      [0,1],[0,15],[15,17],[0,16],[16,18]
    ];

    async function load_keypoints(url) {
      const res = await fetch(url);
      return await res.json();
    }

    function setup_overlay(videoId, canvasId, data) {
      const video = document.getElementById(videoId);
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');

      function draw_frame() {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const frame = Math.floor(video.currentTime * data.fps);
        const kps = data.keypoints[frame];
        if (kps) {
          kps.forEach(([x,y,conf]) => {
            if (conf > 0.3) {
              const px = x * canvas.width;
              const py = y * canvas.height;
              ctx.beginPath();
              ctx.arc(px, py, 3, 0, Math.PI * 2);
              ctx.fillStyle = 'lime';
              ctx.fill();
            }
          });
          POSE_PAIRS.forEach(([a,b]) => {
            const pa = kps[a], pb = kps[b];
            if (pa && pb && pa[2] > 0.3 && pb[2] > 0.3) {
              ctx.beginPath();
              ctx.moveTo(pa[0] * canvas.width, pa[1] * canvas.height);
              ctx.lineTo(pb[0] * canvas.width, pb[1] * canvas.height);
              ctx.strokeStyle = 'blue';
              ctx.lineWidth = 2;
              ctx.stroke();
            }
          });
        }
        requestAnimationFrame(draw_frame);
      }
      requestAnimationFrame(draw_frame);
    }

    if (HAS_RESULTS) {
      Promise.all([
        load_keypoints("{{ url_for('static', filename='reference_keypoints.json') }}"),
        load_keypoints("{{ url_for('static', filename='current_keypoints.json') }}")
      ]).then(([refData, curData]) => {
        setup_overlay('ref-video', 'ref-canvas', refData);
        setup_overlay('cur-video', 'cur-canvas', curData);
      });

      const refVideo = document.getElementById('ref-video');
      const curVideo = document.getElementById('cur-video');

      function sync_play(from, to) {
        if (to.paused) {
          to.currentTime = from.currentTime;
          to.play();
        }
      }

      refVideo.addEventListener('play', () => sync_play(refVideo, curVideo));
      curVideo.addEventListener('play', () => sync_play(curVideo, refVideo));
      refVideo.addEventListener('pause', () => { if (!curVideo.paused) curVideo.pause(); });
      curVideo.addEventListener('pause', () => { if (!refVideo.paused) refVideo.pause(); });
    }

    // 初期表示
    load_video_list();
    if (CHATBOT_ENABLED) {
      init_chat();
    }
    async function update_usage() {
      try {
        const res = await fetch('/system_usage');
        const data = await res.json();
        // Ensure bars display correct metrics
        document.getElementById('cpu-bar').value = data.cpu;
        document.getElementById('gpu-bar').value = data.gpu;
        document.getElementById('npu-bar').value = data.npu;
        document.getElementById('cpu-text').textContent = `${data.cpu.toFixed(1)}%`;
        document.getElementById('gpu-text').textContent = `${data.gpu.toFixed(1)}%`;
        document.getElementById('npu-text').textContent = `${data.npu.toFixed(1)}%`;
      } catch (e) {
        // ignore errors
      }
    }
    setInterval(update_usage, 1000);
    update_usage();
  </script>
</body>
</html>
