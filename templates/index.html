<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>チャット & 動画</title>
  <style>
    body { display: flex; height: 100vh; margin: 0; }
    .video-container, .chat-container { flex: 1; padding: 10px; box-sizing: border-box; }
    .chat-container { display: flex; flex-direction: column; }
    #chat-messages { flex: 1; border: 1px solid #ccc; overflow-y: auto; margin-bottom: 10px; padding: 5px; }
    .chat-input { display: flex; }
    .chat-input input { flex: 1; padding: 5px; }
    .chat-input button { margin-left: 5px; }
    .video-wrapper { display: flex; }
    .video-item { position: relative; flex: 1; }
    .video-item video { width: 100%; display: block; }
    .video-item canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
    .url-input { margin-bottom: 10px; }
    .url-input input { width: 45%; margin-right: 5px; }
    .file-select { margin-bottom: 10px; }
    .file-select select { width: 45%; margin-right: 5px; }
    .file-select input[type="file"] { width: 45%; margin-right: 5px; }
  </style>
</head>
<body>
  <!-- 動画 -->
  <div class="video-container">
    <p>差分スコア: {{ "%.4f"|format(score) if score is not none else "N/A" }}</p>
    <div class="url-input">
      <input id="ref-url" type="text" placeholder="Reference video URL" />
      <input id="cur-url" type="text" placeholder="Current video URL" />
    </div>
    <div class="file-select">
      <input id="ref-upload" type="file" accept="video/mp4" />
      <select id="ref-file"></select>
      <input id="cur-upload" type="file" accept="video/mp4" />
      <select id="cur-file"></select>
      <button id="load-btn">更新</button>
    </div>
    <div class="video-wrapper">
      <div class="video-item">
        <video id="ref-video" controls>
          <source src="{{ url_for('serve_video', filename=ref_video_name) }}" type="video/mp4">
          お使いのブラウザは動画再生に対応していません。
        </video>
        <canvas id="ref-canvas"></canvas>
      </div>
      <div class="video-item">
        <video id="cur-video" controls>
          <source src="{{ url_for('serve_video', filename=cur_video_name) }}" type="video/mp4">
          お使いのブラウザは動画再生に対応していません。
        </video>
        <canvas id="cur-canvas"></canvas>
      </div>
    </div>
  </div>

  <!-- チャット -->
  <div class="chat-container">
    <div id="chat-messages"></div>
    <div class="chat-input">
      <input id="chat-input" type="text" placeholder="メッセージを入力..." />
      <button id="send-btn">送信</button>
    </div>
  </div>

  <script>
    async function loadMessages() {
      const res = await fetch('/messages');
      const msgs = await res.json();
      const box = document.getElementById('chat-messages');
      box.innerHTML = '';
      msgs.forEach(m => {
        const p = document.createElement('p');
        p.textContent = m;
        box.appendChild(p);
      });
    }

    document.getElementById('send-btn').onclick = async () => {
      const input = document.getElementById('chat-input');
      if (!input.value) return;
      await fetch('/messages', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: input.value })
      });
      input.value = '';
      loadMessages();
    };

    document.getElementById('load-btn').onclick = async () => {
      const ref = document.getElementById('ref-url').value;
      const cur = document.getElementById('cur-url').value;
      const refSel = document.getElementById('ref-file').value;
      const curSel = document.getElementById('cur-file').value;
      const refUp = document.getElementById('ref-upload').files[0];
      const curUp = document.getElementById('cur-upload').files[0];

      let refFile = refSel;
      let curFile = curSel;

      if (refUp || curUp) {
        const form = new FormData();
        if (refUp) form.append('reference', refUp);
        if (curUp) form.append('current', curUp);
        const upRes = await fetch('/upload_videos', { method: 'POST', body: form });
        const uploaded = await upRes.json();
        if (uploaded.reference_file) refFile = uploaded.reference_file;
        if (uploaded.current_file) curFile = uploaded.current_file;
      }

      await fetch('/set_videos', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ reference_url: ref, current_url: cur, reference_file: refFile, current_file: curFile })
      });
      location.reload();
    };

    async function loadVideoList() {
      const res = await fetch('/list_videos');
      const files = await res.json();
      const refSel = document.getElementById('ref-file');
      const curSel = document.getElementById('cur-file');
      refSel.innerHTML = '';
      curSel.innerHTML = '';
      files.forEach(f => {
        const o1 = document.createElement('option');
        o1.value = f;
        o1.textContent = f;
        refSel.appendChild(o1);
        const o2 = document.createElement('option');
        o2.value = f;
        o2.textContent = f;
        curSel.appendChild(o2);
      });
      refSel.value = '{{ ref_video_name }}';
      curSel.value = '{{ cur_video_name }}';
    }

    const POSE_PAIRS = [
      [1,2],[2,3],[3,4],
      [1,5],[5,6],[6,7],
      [1,8],[8,9],[9,10],
      [8,12],[12,13],[13,14],
      [0,1],[0,15],[15,17],[0,16],[16,18]
    ];

    async function loadKeypoints(url) {
      const res = await fetch(url);
      return await res.json();
    }

    function setupOverlay(videoId, canvasId, data) {
      const video = document.getElementById(videoId);
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');

      function draw() {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const frame = Math.floor(video.currentTime * data.fps);
        const kps = data.keypoints[frame];
        if (kps) {
          kps.forEach(([x,y,conf]) => {
            if (conf > 0.3) {
              const px = x * canvas.width;
              const py = y * canvas.height;
              ctx.beginPath();
              ctx.arc(px, py, 3, 0, Math.PI * 2);
              ctx.fillStyle = 'lime';
              ctx.fill();
            }
          });
          POSE_PAIRS.forEach(([a,b]) => {
            const pa = kps[a], pb = kps[b];
            if (pa && pb && pa[2] > 0.3 && pb[2] > 0.3) {
              ctx.beginPath();
              ctx.moveTo(pa[0] * canvas.width, pa[1] * canvas.height);
              ctx.lineTo(pb[0] * canvas.width, pb[1] * canvas.height);
              ctx.strokeStyle = 'blue';
              ctx.lineWidth = 2;
              ctx.stroke();
            }
          });
        }
        requestAnimationFrame(draw);
      }
      requestAnimationFrame(draw);
    }

    Promise.all([
      loadKeypoints("{{ url_for('static', filename='reference_keypoints.json') }}"),
      loadKeypoints("{{ url_for('static', filename='current_keypoints.json') }}")
    ]).then(([refData, curData]) => {
      setupOverlay('ref-video', 'ref-canvas', refData);
      setupOverlay('cur-video', 'cur-canvas', curData);
    });

    // 初期表示と1秒おきの更新
    loadMessages();
    loadVideoList();
    setInterval(loadMessages, 1000);
  </script>
</body>
</html>
